# [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 示例

```
示例1：
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

示例 2：
输入: prices = [1]
输出: 0
```

## 思路

动态规划 

- 分析：

  冷冻期指：当天卖掉了股票，因此当天是冷冻期，第二天就不能买股票

  我们设 $f[i]$ 是前 i 天求出的最大利润，现在一共有三个状态：

  1. $f[i][0]$：目前持有股票
  2. $f[i][1]$：目前不持有股票，并且处于冷冻期
  3. $f[i][2]$：目前不持有股票，并且不处于冷冻期

  以上都是第 i 天的状态。

  

- 状态：

  1. $f[i][0]$：目前持有股票
  2. $f[i][1]$：目前不持有股票，并且当天卖掉了股票，处于冷冻期
  3. $f[i][2]$：目前不持有股票，并且不处于冷冻期

- 状态转移方程：

  1. $f[i][0]=max(f[i-1][0],f[i-1][2]-prices[i])$ ：目前持有的股票，可以是之前就持有的；也可以是今天买入的。
  2. $f[i][1]=f[i-1][0]+prices[i]$：说明昨天持有股票，而今天把股票卖掉了。
  3. $f[i][2]=max(f[i-1][1],f[i-1][2])$：如果昨天卖掉了股票，那么今天就不能买股票；如果昨天没有卖股票，那说明没有进行任何操作。

- 初始状态：

  - $f[0][0]=-price[0]$
  - $f[0][1]=0$
  - $f[0][2]=0$

## 代码

```java
class Solution {
    /*
    * 1. f[i][0]：目前持有股票
    * 2. f[i][1]：目前不持有股票，并且处于冷冻期
    * 3. f[i][2]：目前不持有股票，并且不处于冷冻期
    */
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len == 1) return 0;

        int res = 0;
        int[][] f = new int[len][3];
        f[0][0] = -prices[0];
        f[0][1] = 0;
        f[0][2] = 0;

        for(int i = 1; i < len; i++) {
            f[i][0] = Math.max(f[i-1][0], f[i-1][2] - prices[i]);
            f[i][1] = f[i-1][0] + prices[i];
            f[i][2] = Math.max(f[i-1][1], f[i-1][2]);
        }

        return getMax(f[len-1][0], f[len-1][1], f[len-1][2]);
    }

    public int getMax(int i, int j, int k) {
        int res = 0;
        res = i > j ? i : j;
        res = res > k ? res : k;
        return res;
    }
}
```



## 复杂度

时间复杂度：$O(n)$

空间复杂度：$O(3*n)$

