# [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

## 题目

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

```
示例 1：

输入: n = 5, m = 3
输出: 3


示例 2：

输入: n = 10, m = 17
输出: 2
```

## 思路

**约瑟夫环**

例如：

n = 5, m = 3    [0, 1, 2, 3, 4]

![image.png](https://pic.leetcode-cn.com/9dda886441be8d249abb76e35f53f29fd6e780718d4aca2ee3c78f947fb76e75-image.png)

- 对于第一轮
  - 删除 (m - 1) % n 位的值，即 2 % 5 = 2
  - 下一轮从  m % n 开始，即 3 % 5 = 3
- 第二轮变成 [3 ,4 ,0 ,1]，设 t = m % n，t = 3, 则所有数字 x 变成 (x + t) % n,  0 变成 
  - (0 + t) % 5 = 3
  - (1 + t) % 5 = 4
  - (2 + t) % 5 = 0
  - (3 + t) % 5 = 1
  - 删除 (m - 1 + t) % n 位的值，即 (3-1+3) % 5 = 0
  - 下一轮从 (m + t) % n 开始，即 (3 + 3) % 5 = 1
- 由此可得规律，对于任一个数字 $x$ ，$x$ —> ($x$ + m % n) % n
  - 设 n 个数字的约瑟夫环，最后留下数字为 $f(n)$      ($f(n)$ 也是一个数字，满足上述规律)
  - 则 n - 1 个数字的约瑟夫环，最后留下的数字为 $f(n-1)$
  - $f(1) = 0$ ,  $f(n)$ = $(f(n-1)$ + m % n) % n。

## 代码

```java
class Solution {
    /* 约瑟夫环 */
    public int lastRemaining(int n, int m) {
        // 0, 1, 2, ..., n
        // m 是从第 m 个数字开始删
        int res = 0;
        
        for(int i = 2; i <= n; i++) {
            res = (res + m) % i;
        }

        return res;
    }
}
```



## 复杂度

时间复杂度：$O(n)$

空间复杂度：$O(1)$

